---
title: "Using the tidytreatment package with bcf and BART"
author: "Joshua J Bon"
date: "`r Sys.Date()`"
bibliography: vignette.bib
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using tidytreatment}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette simulates data using the scheme described by @Hill2013 with the additional of 1 categorical variable. It it implemented in the function `simulate_hill_su_data()`:

```{r load-data}

  suppressPackageStartupMessages({
    library(bcf)
    library(BART)
    library(tidytreatment)
    library(dplyr)
    library(tidybayes)
    library(ggplot2)
  })

  sim <- simulate_su_hill_data(
    n = 200, treatment_linear = F,  
    omega = 0, add_categorical = T,
    coef_categorical_treatment = c(0,0,1),  
    coef_categorical_nontreatment = c(-1,0,-1)
  )
  
  # non-treated vs treated counts:
  table(sim$data$z)
  
  # view a selection of data
  sim$data %>% select(y, z, c1, x1:x3) %>% head()

```

## Bayesian causal forests using `bcf` and help from `BART`

Let's run the model to be used to assess treatment effects. The process described in @Hahn2017 is to:

1. Perform variable selection on the non-treatment variables $X$ that are related to the outcome $y$. 
  - We will use `BART` to find this subset $X_{S}$.

2. Use the selected variables to construct a propensity score for treatment.
  - i.e. given $X_{S}$, how likely are you to be treated. We will use `BART` to calculate this probability $\hat\pi$.

3. Perform the Bayesian causal forest procedure. 
  - We will use `bcf` for this.


The `BART` and `bcf` packages are the ones used here, but several others are available^[`bartMachine` or `rbart` for example.].  `BART` will fit our standard Bayesian Additive Regression Trees (BART) [@Chipman2010], whilst `bcf` will fit our causal BARTs [@Hahn2017]. The packages can be found on CRAN ( [bcf](https://cran.r-project.org/package=bcf [BART](https://cran.r-project.org/package=BART).
 
```{r run-bart, echo=TRUE, results='hide', cache=FALSE}
  
  # this step is not neccessary but helps with selecting variables
  X_base <- model.matrix(~ . -1, select(sim$dat, -z, -y))

  # regress y ~ covariates BART::wbart is for continuous outcomes
  var_select_bart <- wbart(
    x.train = X_base,
    y.train = select(sim$dat, y)[[1]],
    sparse = T, # use prior for variable selection
    ndpost = 5000,
    nskip = 1000
    )

  # perform a simple (no CV) variable selection from y ~ covariates model
  prop_vars <- (var_select_bart$varprob.mean > 1/length(var_select_bart$varprob.mean)) %>%
    names(.)[.]
  
  prop_vars
  
  # regress z ~ most important covariates to get propensity score. 
  # BART::pbart is for binary outcomes
  prop_bart <- pbart(
    x.train = X_base[,prop_vars],
    y.train = select(sim$dat, z)[[1]],
    sparse = F, # use prior for variable selection
    ndpost = 5000,
    nskip = 1000
    )

  treat_bart <- bcf(
    x_control = X_base,
    x_moderate = X_base,
    z = select(sim$dat, z)[[1]],
    y = select(sim$dat, y)[[1]],
    pihat = prop_bart$prob.train.mean,
    include_pi = "both",
    nsim = 5000,
    nburn = 1000,
    update_interval = 1000
    )
  
  # bcf doesn't give objects a class
  class(treat_bart) <- "bcf"

```

## Model checking and convergence

Here are some examples of model checking we can do.

```{r convergence-bart, echo=TRUE, cache=FALSE}

  res <- residual_draws(var_select_bart, response = sim$data$y, include_newdata = F)
  
  res %>%   
    point_interval(.residual, .fitted, .width = c(0.95) ) %>%
    select(-.fitted.lower, -.fitted.upper) %>%
  ggplot() + 
      geom_pointinterval(aes(x = .fitted, y = .residual, ymin = .residual.lower,  ymax = .residual.upper), alpha = 0.2) +
      scale_fill_brewer() +
      theme_bw() + ggtitle("Residuals vs observations")

  res %>% summarise(.fitted = mean(.fitted), y = first(y)) %>% 
    ggplot(aes(x = y, y = .fitted)) +
    geom_point() + 
    geom_smooth(method = "lm") + 
    geom_abline(slope = 1, intercept = 0) +
    theme_bw() + ggtitle("Observations vs fitted")
  
  res %>% summarise(.residual = mean(.residual)) %>%
    ggplot(aes(sample = .residual)) + 
    geom_qq() + 
    geom_qq_line() + 
    theme_bw() + ggtitle("Q-Q plot of residuals")
  

  
```

## Extract the posterior (tidy style)

Methods for extracting the posterior in a tidy format is included in the `tidytreatment`.

```{r tidy-bart-fit, echo=TRUE, cache=FALSE}

  posterior_fitted <- fitted_draws(bartM, value = "fit", include_newdata = F)
  # The newdata argument (omitted) defaults to the data from the model.
  # include_newdata = F, avoids returning the newdata with the fitted values
  # as it is so large. 
  # The `.row` variable makes sure we know which row in the newdata the fitted
  # value came from (if we dont include the data in the result).
  
  posterior_fitted
  
```

```{r tidy-bart-pred, eval=FALSE, echo=TRUE, cache=FALSE}

  # Function to tidy predicted draws also...
  posterior_pred <- predicted_draws(bartM, include_newdata = F)
  
```

## Use some plotting functions from the `tidybayes` package

Since `tidytreatment` follows the `tidybayes` output specifications, functions from `tidybayes` should work.

```{r plot-tidy-bart, echo=TRUE, cache=FALSE}

  treatment_var_and_c1 <- 
    dat %>% 
    select(z,c1) %>%
    mutate(.row = 1:n(), z = as.factor(z))

  posterior_fitted %>%
    left_join(treatment_var_and_c1, by = ".row") %>%
    ggplot() + 
      geom_eye(aes(x = z, y = fit)) + 
      facet_wrap(~c1, labeller = as_labeller( function(x) paste("c1 =",x) ) ) +
      xlab("Treatment (z)") + ylab("Posterior predicted value") +
      theme_bw() + ggtitle("Effect of treatment with 'c1' on posterior fitted values")

```

## Calculate Treatment Effects

Posterior conditional (average) treatment effects can be calculated using the `treatment_effects` function. This function finds the posterior values of
$$
\text{E}(y ~ \vert~ T = 1, X = x_{i}) - \text{E}(y ~ \vert~ T = 0, X = x_{i}) 
$$
for each unit of measurement, $i$, (e.g. subject) in the data sample.

Some histogram summaries are presented below.

```{r cates-hist, echo=TRUE, cache=FALSE}

# sample based (using data from fit) conditional treatment effects, posterior draws
posterior_treat_eff <- 
  treatment_effects(bartM, treatment = "z") 

posterior_treat_eff %>% 
  ggplot() +
  geom_histogram(aes(x = cte), binwidth = 0.1, colour = "white") + 
  theme_bw() + ggtitle("Histogram of treatment effect (all draws)")
  

posterior_treat_eff %>% summarise(cte_hat = median(cte)) %>%
  ggplot() +
  geom_histogram(aes(x = cte_hat), binwidth = 0.1, colour = "white") + 
  theme_bw() + ggtitle("Histogram of treatment effect (median for each subject)")
  
```

We can also focus on the treatment effects for just those that are treated. 

```{r cates-hist-treated, echo=TRUE, cache=FALSE}

# sample based (using data from fit) conditional treatment effects, posterior draws
posterior_treat_eff_on_treated <- 
  treatment_effects(bartM, treatment = "z", subset = "treated") 

posterior_treat_eff_on_treated %>% 
  ggplot() +
  geom_histogram(aes(x = cte), binwidth = 0.1, colour = "white") + 
  theme_bw() + ggtitle("Histogram of treatment effect (all draws from treated subjects)")

```

Plots can be made that stack each subjects posterior CIs of the CATEs. 

```{r cates-stack-plot, echo=TRUE, cache=FALSE}

posterior_treat_eff %>% select(-z) %>% point_interval() %>%
  arrange(cte) %>% mutate(.orow = 1:n()) %>% 
  ggplot() + 
      geom_interval(aes(x = .orow, y= cte), size = 0.5) +
  geom_point(aes(x = .orow, y = cte), shape = "circle open", alpha = 0.1) + 
      ylab("Median posterior CATE for each subject (95% CI)") +
      theme_bw() + coord_flip() + scale_colour_brewer() +
      theme(axis.title.y = element_blank(), 
            axis.text.y = element_blank(), 
            axis.ticks.y = element_blank(),
            legend.position = "none")

```

We can also plot the CATEs varying over particular covariates. In this example, instead of grouping by subject, we group by the variable of interest, and calculate the posterior summaries over this variable.

```{r cates-line-plot, echo=TRUE, cache=FALSE}

posterior_treat_eff %>%
  left_join(tibble(c1 = dat$c1, .row = 1:length(dat$c1) ), by = ".row") %>%
  group_by(c1) %>%
  ggplot() + 
      geom_eye(aes(x = c1, y = cte), alpha = 0.2) +
      scale_fill_brewer() +
      theme_bw() + ggtitle("Treatment effect by `c1`")


```

## Common support

Common support testing [@hill] can be tested directly, or a Boolean can be included when calculating the treatment effects.

```{r common-support, echo=T, cache=F}

csupp1 <- has_common_support(bartM, treatment = "z", 
                             method = "chisq", cutoff = 0.05)
csupp1 %>% filter(!common_support)

csupp2 <- has_common_support(bartM, treatment = "z", 
                             method = "sd", cutoff = 1)
csupp2 %>% filter(!common_support)

posterior_treat_eff_on_treated <- 
  treatment_effects(bartM, treatment = "z", 
                    subset = "treated", 
                    common_support_method = "sd", cutoff = 1) 

```

## Investigating variable importance

We can count how many times a variables was included in the BART in conjunction with the treatment effect, or overall.

```{r interaction-investigator, echo=T, cache=F}

  treatment_interactions <-
    covariate_with_treatment_importance(bartM, treatment = "z")

  treatment_interactions %>% 
    ggplot() + 
    geom_bar(aes(x = variable, y = avg_inclusion), stat = "identity") +
    theme_bw() + ggtitle("Important variables interacting with treatment ('z')") +
    ylab("Inclusion counts")
  
  variable_importance <-
    covariate_importance(bartM)

  variable_importance %>% 
    ggplot() + 
    geom_bar(aes(x = variable, y = avg_inclusion), stat = "identity") +
    theme_bw() + ggtitle("Important variables overall") +
    ylab("Inclusion counts")
  

```

## References
